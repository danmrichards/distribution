// Package v1 provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package v1

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteBucket request
	DeleteBucket(ctx context.Context, bucketid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBucket request
	GetBucket(ctx context.Context, bucketid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBucket request  with any body
	UpdateBucketWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBucket(ctx context.Context, bucketid string, body UpdateBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBucketAccessTokens request
	ListBucketAccessTokens(ctx context.Context, bucketid string, params *ListBucketAccessTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBucketAccessToken request  with any body
	CreateBucketAccessTokenWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBucketAccessToken(ctx context.Context, bucketid string, body CreateBucketAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBucketAccessToken request
	DeleteBucketAccessToken(ctx context.Context, bucketid string, tokenid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBucketAccessToken request
	GetBucketAccessToken(ctx context.Context, bucketid string, tokenid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBucketAccessTokenInfo request  with any body
	UpdateBucketAccessTokenInfoWithBody(ctx context.Context, bucketid string, tokenid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBucketAccessTokenInfo(ctx context.Context, bucketid string, tokenid string, body UpdateBucketAccessTokenInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBadges request
	ListBadges(ctx context.Context, bucketid string, params *ListBadgesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBadge request  with any body
	UpdateBadgeWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBadge(ctx context.Context, bucketid string, body UpdateBadgeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBadge request
	DeleteBadge(ctx context.Context, bucketid string, badgename string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBadge request
	GetBadge(ctx context.Context, bucketid string, badgename string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReleaseDiff request
	GetReleaseDiff(ctx context.Context, bucketid string, params *GetReleaseDiffParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReleaseDiffEntries request
	GetReleaseDiffEntries(ctx context.Context, bucketid string, params *GetReleaseDiffEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDiff request
	GetDiff(ctx context.Context, bucketid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDiffEntries request
	GetDiffEntries(ctx context.Context, bucketid string, params *GetDiffEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntries request
	GetEntries(ctx context.Context, bucketid string, params *GetEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEntry request  with any body
	CreateEntryWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEntry(ctx context.Context, bucketid string, body CreateEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEntry request
	DeleteEntry(ctx context.Context, bucketid string, entryid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntry request
	GetEntry(ctx context.Context, bucketid string, entryid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEntry request  with any body
	UpdateEntryWithBody(ctx context.Context, bucketid string, entryid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEntry(ctx context.Context, bucketid string, entryid string, body UpdateEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContent request
	GetContent(ctx context.Context, bucketid string, entryid string, params *GetContentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContentStatus request
	GetContentStatus(ctx context.Context, bucketid string, entryid string, params *GetContentStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadContent request  with any body
	UploadContentWithBody(ctx context.Context, bucketid string, entryid string, params *UploadContentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateContent request
	CreateContent(ctx context.Context, bucketid string, entryid string, params *CreateContentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntryVersions request
	GetEntryVersions(ctx context.Context, bucketid string, entryid string, params *GetEntryVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntryVersion request
	GetEntryVersion(ctx context.Context, bucketid string, entryid string, versionid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContentVersion request
	GetContentVersion(ctx context.Context, bucketid string, entryid string, versionid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContentStatusVersion request
	GetContentStatusVersion(ctx context.Context, bucketid string, entryid string, versionid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntryByPath request
	GetEntryByPath(ctx context.Context, bucketid string, params *GetEntryByPathParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateEntryByPath request  with any body
	CreateOrUpdateEntryByPathWithBody(ctx context.Context, bucketid string, params *CreateOrUpdateEntryByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateEntryByPath(ctx context.Context, bucketid string, params *CreateOrUpdateEntryByPathParams, body CreateOrUpdateEntryByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEntryByPath request  with any body
	UpdateEntryByPathWithBody(ctx context.Context, bucketid string, params *UpdateEntryByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEntryByPath(ctx context.Context, bucketid string, params *UpdateEntryByPathParams, body UpdateEntryByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePermissionByBucket request
	DeletePermissionByBucket(ctx context.Context, bucketid string, params *DeletePermissionByBucketParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllByBucket request
	GetAllByBucket(ctx context.Context, bucketid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePermissionByBucket request  with any body
	CreatePermissionByBucketWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePermissionByBucket(ctx context.Context, bucketid string, body CreatePermissionByBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePermissionByBucket request  with any body
	UpdatePermissionByBucketWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePermissionByBucket(ctx context.Context, bucketid string, body UpdatePermissionByBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PromoteBucket request  with any body
	PromoteBucketWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PromoteBucket(ctx context.Context, bucketid string, body PromoteBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPromotion request
	GetPromotion(ctx context.Context, bucketid string, promotionid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PromoteBucketAsync request  with any body
	PromoteBucketAsyncWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PromoteBucketAsync(ctx context.Context, bucketid string, body PromoteBucketAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReleaseByBadge request
	GetReleaseByBadge(ctx context.Context, bucketid string, badgename string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReleaseEntriesByBadge request
	GetReleaseEntriesByBadge(ctx context.Context, bucketid string, badgename string, params *GetReleaseEntriesByBadgeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReleases request
	GetReleases(ctx context.Context, bucketid string, params *GetReleasesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRelease request  with any body
	CreateReleaseWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRelease(ctx context.Context, bucketid string, body CreateReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRelease request
	GetRelease(ctx context.Context, bucketid string, releaseid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRelease request  with any body
	UpdateReleaseWithBody(ctx context.Context, bucketid string, releaseid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRelease(ctx context.Context, bucketid string, releaseid string, body UpdateReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReleaseEntries request
	GetReleaseEntries(ctx context.Context, bucketid string, releaseid string, params *GetReleaseEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStats request
	GetStats(ctx context.Context, bucketid string, releaseid string, params *GetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetErrorDetails request
	GetErrorDetails(ctx context.Context, bucketid string, releaseid string, params *GetErrorDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrg request
	GetOrg(ctx context.Context, orgid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveTosAccepted request  with any body
	SaveTosAcceptedWithBody(ctx context.Context, orgid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveTosAccepted(ctx context.Context, orgid string, body SaveTosAcceptedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrgUsage request
	GetOrgUsage(ctx context.Context, orgid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBucketsByProject request
	ListBucketsByProject(ctx context.Context, projectguid string, params *ListBucketsByProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBucketByProject request  with any body
	CreateBucketByProjectWithBody(ctx context.Context, projectguid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBucketByProject(ctx context.Context, projectguid string, body CreateBucketByProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserInfo request
	GetUserInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserApiKey request
	GetUserApiKey(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegenerateUserApiKey request  with any body
	RegenerateUserApiKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegenerateUserApiKey(ctx context.Context, body RegenerateUserApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DeleteBucket(ctx context.Context, bucketid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBucketRequest(c.Server, bucketid)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBucket(ctx context.Context, bucketid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBucketRequest(c.Server, bucketid)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBucketWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBucketRequestWithBody(c.Server, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBucket(ctx context.Context, bucketid string, body UpdateBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBucketRequest(c.Server, bucketid, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBucketAccessTokens(ctx context.Context, bucketid string, params *ListBucketAccessTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBucketAccessTokensRequest(c.Server, bucketid, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBucketAccessTokenWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBucketAccessTokenRequestWithBody(c.Server, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBucketAccessToken(ctx context.Context, bucketid string, body CreateBucketAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBucketAccessTokenRequest(c.Server, bucketid, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBucketAccessToken(ctx context.Context, bucketid string, tokenid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBucketAccessTokenRequest(c.Server, bucketid, tokenid)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBucketAccessToken(ctx context.Context, bucketid string, tokenid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBucketAccessTokenRequest(c.Server, bucketid, tokenid)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBucketAccessTokenInfoWithBody(ctx context.Context, bucketid string, tokenid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBucketAccessTokenInfoRequestWithBody(c.Server, bucketid, tokenid, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBucketAccessTokenInfo(ctx context.Context, bucketid string, tokenid string, body UpdateBucketAccessTokenInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBucketAccessTokenInfoRequest(c.Server, bucketid, tokenid, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBadges(ctx context.Context, bucketid string, params *ListBadgesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBadgesRequest(c.Server, bucketid, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBadgeWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBadgeRequestWithBody(c.Server, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBadge(ctx context.Context, bucketid string, body UpdateBadgeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBadgeRequest(c.Server, bucketid, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBadge(ctx context.Context, bucketid string, badgename string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBadgeRequest(c.Server, bucketid, badgename)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBadge(ctx context.Context, bucketid string, badgename string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBadgeRequest(c.Server, bucketid, badgename)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReleaseDiff(ctx context.Context, bucketid string, params *GetReleaseDiffParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReleaseDiffRequest(c.Server, bucketid, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReleaseDiffEntries(ctx context.Context, bucketid string, params *GetReleaseDiffEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReleaseDiffEntriesRequest(c.Server, bucketid, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDiff(ctx context.Context, bucketid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDiffRequest(c.Server, bucketid)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDiffEntries(ctx context.Context, bucketid string, params *GetDiffEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDiffEntriesRequest(c.Server, bucketid, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntries(ctx context.Context, bucketid string, params *GetEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntriesRequest(c.Server, bucketid, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEntryWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEntryRequestWithBody(c.Server, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEntry(ctx context.Context, bucketid string, body CreateEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEntryRequest(c.Server, bucketid, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEntry(ctx context.Context, bucketid string, entryid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEntryRequest(c.Server, bucketid, entryid)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntry(ctx context.Context, bucketid string, entryid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntryRequest(c.Server, bucketid, entryid)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEntryWithBody(ctx context.Context, bucketid string, entryid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEntryRequestWithBody(c.Server, bucketid, entryid, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEntry(ctx context.Context, bucketid string, entryid string, body UpdateEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEntryRequest(c.Server, bucketid, entryid, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContent(ctx context.Context, bucketid string, entryid string, params *GetContentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContentRequest(c.Server, bucketid, entryid, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContentStatus(ctx context.Context, bucketid string, entryid string, params *GetContentStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContentStatusRequest(c.Server, bucketid, entryid, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadContentWithBody(ctx context.Context, bucketid string, entryid string, params *UploadContentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadContentRequestWithBody(c.Server, bucketid, entryid, params, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContent(ctx context.Context, bucketid string, entryid string, params *CreateContentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateContentRequest(c.Server, bucketid, entryid, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntryVersions(ctx context.Context, bucketid string, entryid string, params *GetEntryVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntryVersionsRequest(c.Server, bucketid, entryid, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntryVersion(ctx context.Context, bucketid string, entryid string, versionid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntryVersionRequest(c.Server, bucketid, entryid, versionid)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContentVersion(ctx context.Context, bucketid string, entryid string, versionid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContentVersionRequest(c.Server, bucketid, entryid, versionid)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContentStatusVersion(ctx context.Context, bucketid string, entryid string, versionid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContentStatusVersionRequest(c.Server, bucketid, entryid, versionid)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntryByPath(ctx context.Context, bucketid string, params *GetEntryByPathParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntryByPathRequest(c.Server, bucketid, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateEntryByPathWithBody(ctx context.Context, bucketid string, params *CreateOrUpdateEntryByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateEntryByPathRequestWithBody(c.Server, bucketid, params, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateEntryByPath(ctx context.Context, bucketid string, params *CreateOrUpdateEntryByPathParams, body CreateOrUpdateEntryByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateEntryByPathRequest(c.Server, bucketid, params, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEntryByPathWithBody(ctx context.Context, bucketid string, params *UpdateEntryByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEntryByPathRequestWithBody(c.Server, bucketid, params, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEntryByPath(ctx context.Context, bucketid string, params *UpdateEntryByPathParams, body UpdateEntryByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEntryByPathRequest(c.Server, bucketid, params, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePermissionByBucket(ctx context.Context, bucketid string, params *DeletePermissionByBucketParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePermissionByBucketRequest(c.Server, bucketid, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllByBucket(ctx context.Context, bucketid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllByBucketRequest(c.Server, bucketid)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePermissionByBucketWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePermissionByBucketRequestWithBody(c.Server, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePermissionByBucket(ctx context.Context, bucketid string, body CreatePermissionByBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePermissionByBucketRequest(c.Server, bucketid, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePermissionByBucketWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePermissionByBucketRequestWithBody(c.Server, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePermissionByBucket(ctx context.Context, bucketid string, body UpdatePermissionByBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePermissionByBucketRequest(c.Server, bucketid, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromoteBucketWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromoteBucketRequestWithBody(c.Server, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromoteBucket(ctx context.Context, bucketid string, body PromoteBucketJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromoteBucketRequest(c.Server, bucketid, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPromotion(ctx context.Context, bucketid string, promotionid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPromotionRequest(c.Server, bucketid, promotionid)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromoteBucketAsyncWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromoteBucketAsyncRequestWithBody(c.Server, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PromoteBucketAsync(ctx context.Context, bucketid string, body PromoteBucketAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPromoteBucketAsyncRequest(c.Server, bucketid, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReleaseByBadge(ctx context.Context, bucketid string, badgename string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReleaseByBadgeRequest(c.Server, bucketid, badgename)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReleaseEntriesByBadge(ctx context.Context, bucketid string, badgename string, params *GetReleaseEntriesByBadgeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReleaseEntriesByBadgeRequest(c.Server, bucketid, badgename, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReleases(ctx context.Context, bucketid string, params *GetReleasesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReleasesRequest(c.Server, bucketid, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReleaseWithBody(ctx context.Context, bucketid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReleaseRequestWithBody(c.Server, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRelease(ctx context.Context, bucketid string, body CreateReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReleaseRequest(c.Server, bucketid, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRelease(ctx context.Context, bucketid string, releaseid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReleaseRequest(c.Server, bucketid, releaseid)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateReleaseWithBody(ctx context.Context, bucketid string, releaseid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateReleaseRequestWithBody(c.Server, bucketid, releaseid, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRelease(ctx context.Context, bucketid string, releaseid string, body UpdateReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateReleaseRequest(c.Server, bucketid, releaseid, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReleaseEntries(ctx context.Context, bucketid string, releaseid string, params *GetReleaseEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReleaseEntriesRequest(c.Server, bucketid, releaseid, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStats(ctx context.Context, bucketid string, releaseid string, params *GetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsRequest(c.Server, bucketid, releaseid, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetErrorDetails(ctx context.Context, bucketid string, releaseid string, params *GetErrorDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetErrorDetailsRequest(c.Server, bucketid, releaseid, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrg(ctx context.Context, orgid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrgRequest(c.Server, orgid)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveTosAcceptedWithBody(ctx context.Context, orgid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveTosAcceptedRequestWithBody(c.Server, orgid, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveTosAccepted(ctx context.Context, orgid string, body SaveTosAcceptedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveTosAcceptedRequest(c.Server, orgid, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrgUsage(ctx context.Context, orgid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrgUsageRequest(c.Server, orgid)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBucketsByProject(ctx context.Context, projectguid string, params *ListBucketsByProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBucketsByProjectRequest(c.Server, projectguid, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBucketByProjectWithBody(ctx context.Context, projectguid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBucketByProjectRequestWithBody(c.Server, projectguid, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBucketByProject(ctx context.Context, projectguid string, body CreateBucketByProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBucketByProjectRequest(c.Server, projectguid, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserApiKey(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserApiKeyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegenerateUserApiKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegenerateUserApiKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegenerateUserApiKey(ctx context.Context, body RegenerateUserApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegenerateUserApiKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteBucketRequest generates requests for DeleteBucket
func NewDeleteBucketRequest(server string, bucketid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBucketRequest generates requests for GetBucket
func NewGetBucketRequest(server string, bucketid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBucketRequest calls the generic UpdateBucket builder with application/json body
func NewUpdateBucketRequest(server string, bucketid string, body UpdateBucketJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBucketRequestWithBody(server, bucketid, "application/json", bodyReader)
}

// NewUpdateBucketRequestWithBody generates requests for UpdateBucket with any type of body
func NewUpdateBucketRequestWithBody(server string, bucketid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBucketAccessTokensRequest generates requests for ListBucketAccessTokens
func NewListBucketAccessTokensRequest(server string, bucketid string, params *ListBucketAccessTokensParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/accesstokens/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page", *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "per_page", *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBucketAccessTokenRequest calls the generic CreateBucketAccessToken builder with application/json body
func NewCreateBucketAccessTokenRequest(server string, bucketid string, body CreateBucketAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBucketAccessTokenRequestWithBody(server, bucketid, "application/json", bodyReader)
}

// NewCreateBucketAccessTokenRequestWithBody generates requests for CreateBucketAccessToken with any type of body
func NewCreateBucketAccessTokenRequestWithBody(server string, bucketid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/accesstokens/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBucketAccessTokenRequest generates requests for DeleteBucketAccessToken
func NewDeleteBucketAccessTokenRequest(server string, bucketid string, tokenid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tokenid", tokenid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/accesstokens/%s/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBucketAccessTokenRequest generates requests for GetBucketAccessToken
func NewGetBucketAccessTokenRequest(server string, bucketid string, tokenid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tokenid", tokenid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/accesstokens/%s/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBucketAccessTokenInfoRequest calls the generic UpdateBucketAccessTokenInfo builder with application/json body
func NewUpdateBucketAccessTokenInfoRequest(server string, bucketid string, tokenid string, body UpdateBucketAccessTokenInfoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBucketAccessTokenInfoRequestWithBody(server, bucketid, tokenid, "application/json", bodyReader)
}

// NewUpdateBucketAccessTokenInfoRequestWithBody generates requests for UpdateBucketAccessTokenInfo with any type of body
func NewUpdateBucketAccessTokenInfoRequestWithBody(server string, bucketid string, tokenid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tokenid", tokenid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/accesstokens/%s/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBadgesRequest generates requests for ListBadges
func NewListBadgesRequest(server string, bucketid string, params *ListBadgesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/badges/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page", *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "per_page", *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBadgeRequest calls the generic UpdateBadge builder with application/json body
func NewUpdateBadgeRequest(server string, bucketid string, body UpdateBadgeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBadgeRequestWithBody(server, bucketid, "application/json", bodyReader)
}

// NewUpdateBadgeRequestWithBody generates requests for UpdateBadge with any type of body
func NewUpdateBadgeRequestWithBody(server string, bucketid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/badges/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBadgeRequest generates requests for DeleteBadge
func NewDeleteBadgeRequest(server string, bucketid string, badgename string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "badgename", badgename)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/badges/%s/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBadgeRequest generates requests for GetBadge
func NewGetBadgeRequest(server string, bucketid string, badgename string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "badgename", badgename)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/badges/%s/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReleaseDiffRequest generates requests for GetReleaseDiff
func NewGetReleaseDiffRequest(server string, bucketid string, params *GetReleaseDiffParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/diff/releases/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", true, "fromreleaseid", params.Fromreleaseid); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParam("form", true, "fromreleasenum", params.Fromreleasenum); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Toreleaseid != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "toreleaseid", *params.Toreleaseid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Toreleasenum != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "toreleasenum", *params.Toreleasenum); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReleaseDiffEntriesRequest generates requests for GetReleaseDiffEntries
func NewGetReleaseDiffEntriesRequest(server string, bucketid string, params *GetReleaseDiffEntriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/diff/releases/entries/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Fromreleaseid != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "fromreleaseid", *params.Fromreleaseid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Fromreleasenum != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "fromreleasenum", *params.Fromreleasenum); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Toreleaseid != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "toreleaseid", *params.Toreleaseid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Toreleasenum != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "toreleasenum", *params.Toreleasenum); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page", *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "per_page", *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Path != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "path", *params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeStates != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include_states", *params.IncludeStates); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDiffRequest generates requests for GetDiff
func NewGetDiffRequest(server string, bucketid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/diff/unreleased/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDiffEntriesRequest generates requests for GetDiffEntries
func NewGetDiffEntriesRequest(server string, bucketid string, params *GetDiffEntriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/diff/unreleased/entries/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page", *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "per_page", *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Path != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "path", *params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeStates != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include_states", *params.IncludeStates); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntriesRequest generates requests for GetEntries
func NewGetEntriesRequest(server string, bucketid string, params *GetEntriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/entries/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Path != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "path", *params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Label != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "label", *params.Label); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page", *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "per_page", *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEntryRequest calls the generic CreateEntry builder with application/json body
func NewCreateEntryRequest(server string, bucketid string, body CreateEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEntryRequestWithBody(server, bucketid, "application/json", bodyReader)
}

// NewCreateEntryRequestWithBody generates requests for CreateEntry with any type of body
func NewCreateEntryRequestWithBody(server string, bucketid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/entries/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEntryRequest generates requests for DeleteEntry
func NewDeleteEntryRequest(server string, bucketid string, entryid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "entryid", entryid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/entries/%s/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntryRequest generates requests for GetEntry
func NewGetEntryRequest(server string, bucketid string, entryid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "entryid", entryid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/entries/%s/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEntryRequest calls the generic UpdateEntry builder with application/json body
func NewUpdateEntryRequest(server string, bucketid string, entryid string, body UpdateEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEntryRequestWithBody(server, bucketid, entryid, "application/json", bodyReader)
}

// NewUpdateEntryRequestWithBody generates requests for UpdateEntry with any type of body
func NewUpdateEntryRequestWithBody(server string, bucketid string, entryid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "entryid", entryid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/entries/%s/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetContentRequest generates requests for GetContent
func NewGetContentRequest(server string, bucketid string, entryid string, params *GetContentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "entryid", entryid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/entries/%s/content/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Versionid != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "versionid", *params.Versionid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContentStatusRequest generates requests for GetContentStatus
func NewGetContentStatusRequest(server string, bucketid string, entryid string, params *GetContentStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "entryid", entryid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/entries/%s/content/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Versionid != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "versionid", *params.Versionid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("HEAD", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadContentRequestWithBody generates requests for UploadContent with any type of body
func NewUploadContentRequestWithBody(server string, bucketid string, entryid string, params *UploadContentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "entryid", entryid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/entries/%s/content/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Versionid != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "versionid", *params.Versionid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateContentRequest generates requests for CreateContent
func NewCreateContentRequest(server string, bucketid string, entryid string, params *CreateContentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "entryid", entryid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/entries/%s/content/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Versionid != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "versionid", *params.Versionid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntryVersionsRequest generates requests for GetEntryVersions
func NewGetEntryVersionsRequest(server string, bucketid string, entryid string, params *GetEntryVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "entryid", entryid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/entries/%s/versions/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Label != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "label", *params.Label); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page", *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "per_page", *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntryVersionRequest generates requests for GetEntryVersion
func NewGetEntryVersionRequest(server string, bucketid string, entryid string, versionid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "entryid", entryid)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "versionid", versionid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/entries/%s/versions/%s/", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContentVersionRequest generates requests for GetContentVersion
func NewGetContentVersionRequest(server string, bucketid string, entryid string, versionid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "entryid", entryid)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "versionid", versionid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/entries/%s/versions/%s/content/", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContentStatusVersionRequest generates requests for GetContentStatusVersion
func NewGetContentStatusVersionRequest(server string, bucketid string, entryid string, versionid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "entryid", entryid)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "versionid", versionid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/entries/%s/versions/%s/content/", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("HEAD", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntryByPathRequest generates requests for GetEntryByPath
func NewGetEntryByPathRequest(server string, bucketid string, params *GetEntryByPathParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/entry_by_path/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", true, "path", params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Versionid != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "versionid", *params.Versionid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateEntryByPathRequest calls the generic CreateOrUpdateEntryByPath builder with application/json body
func NewCreateOrUpdateEntryByPathRequest(server string, bucketid string, params *CreateOrUpdateEntryByPathParams, body CreateOrUpdateEntryByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateEntryByPathRequestWithBody(server, bucketid, params, "application/json", bodyReader)
}

// NewCreateOrUpdateEntryByPathRequestWithBody generates requests for CreateOrUpdateEntryByPath with any type of body
func NewCreateOrUpdateEntryByPathRequestWithBody(server string, bucketid string, params *CreateOrUpdateEntryByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/entry_by_path/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", true, "path", params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.UpdateIfExists != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "updateIfExists", *params.UpdateIfExists); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateEntryByPathRequest calls the generic UpdateEntryByPath builder with application/json body
func NewUpdateEntryByPathRequest(server string, bucketid string, params *UpdateEntryByPathParams, body UpdateEntryByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEntryByPathRequestWithBody(server, bucketid, params, "application/json", bodyReader)
}

// NewUpdateEntryByPathRequestWithBody generates requests for UpdateEntryByPath with any type of body
func NewUpdateEntryByPathRequestWithBody(server string, bucketid string, params *UpdateEntryByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/entry_by_path/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", true, "path", params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePermissionByBucketRequest generates requests for DeletePermissionByBucket
func NewDeletePermissionByBucketRequest(server string, bucketid string, params *DeletePermissionByBucketParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/permissions/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Permission != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "permission", *params.Permission); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Action != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "action", *params.Action); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllByBucketRequest generates requests for GetAllByBucket
func NewGetAllByBucketRequest(server string, bucketid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/permissions/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePermissionByBucketRequest calls the generic CreatePermissionByBucket builder with application/json body
func NewCreatePermissionByBucketRequest(server string, bucketid string, body CreatePermissionByBucketJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePermissionByBucketRequestWithBody(server, bucketid, "application/json", bodyReader)
}

// NewCreatePermissionByBucketRequestWithBody generates requests for CreatePermissionByBucket with any type of body
func NewCreatePermissionByBucketRequestWithBody(server string, bucketid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/permissions/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdatePermissionByBucketRequest calls the generic UpdatePermissionByBucket builder with application/json body
func NewUpdatePermissionByBucketRequest(server string, bucketid string, body UpdatePermissionByBucketJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePermissionByBucketRequestWithBody(server, bucketid, "application/json", bodyReader)
}

// NewUpdatePermissionByBucketRequestWithBody generates requests for UpdatePermissionByBucket with any type of body
func NewUpdatePermissionByBucketRequestWithBody(server string, bucketid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/permissions/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPromoteBucketRequest calls the generic PromoteBucket builder with application/json body
func NewPromoteBucketRequest(server string, bucketid string, body PromoteBucketJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPromoteBucketRequestWithBody(server, bucketid, "application/json", bodyReader)
}

// NewPromoteBucketRequestWithBody generates requests for PromoteBucket with any type of body
func NewPromoteBucketRequestWithBody(server string, bucketid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/promote/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPromotionRequest generates requests for GetPromotion
func NewGetPromotionRequest(server string, bucketid string, promotionid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "promotionid", promotionid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/promote/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPromoteBucketAsyncRequest calls the generic PromoteBucketAsync builder with application/json body
func NewPromoteBucketAsyncRequest(server string, bucketid string, body PromoteBucketAsyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPromoteBucketAsyncRequestWithBody(server, bucketid, "application/json", bodyReader)
}

// NewPromoteBucketAsyncRequestWithBody generates requests for PromoteBucketAsync with any type of body
func NewPromoteBucketAsyncRequestWithBody(server string, bucketid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/promoteasync/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReleaseByBadgeRequest generates requests for GetReleaseByBadge
func NewGetReleaseByBadgeRequest(server string, bucketid string, badgename string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "badgename", badgename)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/release_by_badge/%s/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReleaseEntriesByBadgeRequest generates requests for GetReleaseEntriesByBadge
func NewGetReleaseEntriesByBadgeRequest(server string, bucketid string, badgename string, params *GetReleaseEntriesByBadgeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "badgename", badgename)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/release_by_badge/%s/entries/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Label != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "label", *params.Label); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page", *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "per_page", *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReleasesRequest generates requests for GetReleases
func NewGetReleasesRequest(server string, bucketid string, params *GetReleasesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/releases/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page", *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "per_page", *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateReleaseRequest calls the generic CreateRelease builder with application/json body
func NewCreateReleaseRequest(server string, bucketid string, body CreateReleaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateReleaseRequestWithBody(server, bucketid, "application/json", bodyReader)
}

// NewCreateReleaseRequestWithBody generates requests for CreateRelease with any type of body
func NewCreateReleaseRequestWithBody(server string, bucketid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/releases/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReleaseRequest generates requests for GetRelease
func NewGetReleaseRequest(server string, bucketid string, releaseid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "releaseid", releaseid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/releases/%s/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateReleaseRequest calls the generic UpdateRelease builder with application/json body
func NewUpdateReleaseRequest(server string, bucketid string, releaseid string, body UpdateReleaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateReleaseRequestWithBody(server, bucketid, releaseid, "application/json", bodyReader)
}

// NewUpdateReleaseRequestWithBody generates requests for UpdateRelease with any type of body
func NewUpdateReleaseRequestWithBody(server string, bucketid string, releaseid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "releaseid", releaseid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/releases/%s/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReleaseEntriesRequest generates requests for GetReleaseEntries
func NewGetReleaseEntriesRequest(server string, bucketid string, releaseid string, params *GetReleaseEntriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "releaseid", releaseid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/releases/%s/entries/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Label != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "label", *params.Label); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page", *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "per_page", *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatsRequest generates requests for GetStats
func NewGetStatsRequest(server string, bucketid string, releaseid string, params *GetStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "releaseid", releaseid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/releases/%s/stats/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", true, "metric", params.Metric); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParam("form", true, "interval", params.Interval); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetErrorDetailsRequest generates requests for GetErrorDetails
func NewGetErrorDetailsRequest(server string, bucketid string, releaseid string, params *GetErrorDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "bucketid", bucketid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "releaseid", releaseid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/buckets/%s/releases/%s/stats/details/errors/", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "per_page", *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParam("form", true, "interval", params.Interval); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrgRequest generates requests for GetOrg
func NewGetOrgRequest(server string, orgid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "orgid", orgid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/orgs/%s/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveTosAcceptedRequest calls the generic SaveTosAccepted builder with application/json body
func NewSaveTosAcceptedRequest(server string, orgid string, body SaveTosAcceptedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveTosAcceptedRequestWithBody(server, orgid, "application/json", bodyReader)
}

// NewSaveTosAcceptedRequestWithBody generates requests for SaveTosAccepted with any type of body
func NewSaveTosAcceptedRequestWithBody(server string, orgid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "orgid", orgid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/orgs/%s/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrgUsageRequest generates requests for GetOrgUsage
func NewGetOrgUsageRequest(server string, orgid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "orgid", orgid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/orgs/%s/usage/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBucketsByProjectRequest generates requests for ListBucketsByProject
func NewListBucketsByProjectRequest(server string, projectguid string, params *ListBucketsByProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "projectguid", projectguid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/projects/%s/buckets/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "page", *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "per_page", *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBucketByProjectRequest calls the generic CreateBucketByProject builder with application/json body
func NewCreateBucketByProjectRequest(server string, projectguid string, body CreateBucketByProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBucketByProjectRequestWithBody(server, projectguid, "application/json", bodyReader)
}

// NewCreateBucketByProjectRequestWithBody generates requests for CreateBucketByProject with any type of body
func NewCreateBucketByProjectRequestWithBody(server string, projectguid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "projectguid", projectguid)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/projects/%s/buckets/", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserInfoRequest generates requests for GetUserInfo
func NewGetUserInfoRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/users/me/")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserApiKeyRequest generates requests for GetUserApiKey
func NewGetUserApiKeyRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/users/me/apikey/")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegenerateUserApiKeyRequest calls the generic RegenerateUserApiKey builder with application/json body
func NewRegenerateUserApiKeyRequest(server string, body RegenerateUserApiKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegenerateUserApiKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewRegenerateUserApiKeyRequestWithBody generates requests for RegenerateUserApiKey with any type of body
func NewRegenerateUserApiKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/api/v1/users/me/apikey/")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	req = req.WithContext(ctx)
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteBucket request
	DeleteBucketWithResponse(ctx context.Context, bucketid string) (*DeleteBucketResponse, error)

	// GetBucket request
	GetBucketWithResponse(ctx context.Context, bucketid string) (*GetBucketResponse, error)

	// UpdateBucket request  with any body
	UpdateBucketWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*UpdateBucketResponse, error)

	UpdateBucketWithResponse(ctx context.Context, bucketid string, body UpdateBucketJSONRequestBody) (*UpdateBucketResponse, error)

	// ListBucketAccessTokens request
	ListBucketAccessTokensWithResponse(ctx context.Context, bucketid string, params *ListBucketAccessTokensParams) (*ListBucketAccessTokensResponse, error)

	// CreateBucketAccessToken request  with any body
	CreateBucketAccessTokenWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*CreateBucketAccessTokenResponse, error)

	CreateBucketAccessTokenWithResponse(ctx context.Context, bucketid string, body CreateBucketAccessTokenJSONRequestBody) (*CreateBucketAccessTokenResponse, error)

	// DeleteBucketAccessToken request
	DeleteBucketAccessTokenWithResponse(ctx context.Context, bucketid string, tokenid string) (*DeleteBucketAccessTokenResponse, error)

	// GetBucketAccessToken request
	GetBucketAccessTokenWithResponse(ctx context.Context, bucketid string, tokenid string) (*GetBucketAccessTokenResponse, error)

	// UpdateBucketAccessTokenInfo request  with any body
	UpdateBucketAccessTokenInfoWithBodyWithResponse(ctx context.Context, bucketid string, tokenid string, contentType string, body io.Reader) (*UpdateBucketAccessTokenInfoResponse, error)

	UpdateBucketAccessTokenInfoWithResponse(ctx context.Context, bucketid string, tokenid string, body UpdateBucketAccessTokenInfoJSONRequestBody) (*UpdateBucketAccessTokenInfoResponse, error)

	// ListBadges request
	ListBadgesWithResponse(ctx context.Context, bucketid string, params *ListBadgesParams) (*ListBadgesResponse, error)

	// UpdateBadge request  with any body
	UpdateBadgeWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*UpdateBadgeResponse, error)

	UpdateBadgeWithResponse(ctx context.Context, bucketid string, body UpdateBadgeJSONRequestBody) (*UpdateBadgeResponse, error)

	// DeleteBadge request
	DeleteBadgeWithResponse(ctx context.Context, bucketid string, badgename string) (*DeleteBadgeResponse, error)

	// GetBadge request
	GetBadgeWithResponse(ctx context.Context, bucketid string, badgename string) (*GetBadgeResponse, error)

	// GetReleaseDiff request
	GetReleaseDiffWithResponse(ctx context.Context, bucketid string, params *GetReleaseDiffParams) (*GetReleaseDiffResponse, error)

	// GetReleaseDiffEntries request
	GetReleaseDiffEntriesWithResponse(ctx context.Context, bucketid string, params *GetReleaseDiffEntriesParams) (*GetReleaseDiffEntriesResponse, error)

	// GetDiff request
	GetDiffWithResponse(ctx context.Context, bucketid string) (*GetDiffResponse, error)

	// GetDiffEntries request
	GetDiffEntriesWithResponse(ctx context.Context, bucketid string, params *GetDiffEntriesParams) (*GetDiffEntriesResponse, error)

	// GetEntries request
	GetEntriesWithResponse(ctx context.Context, bucketid string, params *GetEntriesParams) (*GetEntriesResponse, error)

	// CreateEntry request  with any body
	CreateEntryWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*CreateEntryResponse, error)

	CreateEntryWithResponse(ctx context.Context, bucketid string, body CreateEntryJSONRequestBody) (*CreateEntryResponse, error)

	// DeleteEntry request
	DeleteEntryWithResponse(ctx context.Context, bucketid string, entryid string) (*DeleteEntryResponse, error)

	// GetEntry request
	GetEntryWithResponse(ctx context.Context, bucketid string, entryid string) (*GetEntryResponse, error)

	// UpdateEntry request  with any body
	UpdateEntryWithBodyWithResponse(ctx context.Context, bucketid string, entryid string, contentType string, body io.Reader) (*UpdateEntryResponse, error)

	UpdateEntryWithResponse(ctx context.Context, bucketid string, entryid string, body UpdateEntryJSONRequestBody) (*UpdateEntryResponse, error)

	// GetContent request
	GetContentWithResponse(ctx context.Context, bucketid string, entryid string, params *GetContentParams) (*GetContentResponse, error)

	// GetContentStatus request
	GetContentStatusWithResponse(ctx context.Context, bucketid string, entryid string, params *GetContentStatusParams) (*GetContentStatusResponse, error)

	// UploadContent request  with any body
	UploadContentWithBodyWithResponse(ctx context.Context, bucketid string, entryid string, params *UploadContentParams, contentType string, body io.Reader) (*UploadContentResponse, error)

	// CreateContent request
	CreateContentWithResponse(ctx context.Context, bucketid string, entryid string, params *CreateContentParams) (*CreateContentResponse, error)

	// GetEntryVersions request
	GetEntryVersionsWithResponse(ctx context.Context, bucketid string, entryid string, params *GetEntryVersionsParams) (*GetEntryVersionsResponse, error)

	// GetEntryVersion request
	GetEntryVersionWithResponse(ctx context.Context, bucketid string, entryid string, versionid string) (*GetEntryVersionResponse, error)

	// GetContentVersion request
	GetContentVersionWithResponse(ctx context.Context, bucketid string, entryid string, versionid string) (*GetContentVersionResponse, error)

	// GetContentStatusVersion request
	GetContentStatusVersionWithResponse(ctx context.Context, bucketid string, entryid string, versionid string) (*GetContentStatusVersionResponse, error)

	// GetEntryByPath request
	GetEntryByPathWithResponse(ctx context.Context, bucketid string, params *GetEntryByPathParams) (*GetEntryByPathResponse, error)

	// CreateOrUpdateEntryByPath request  with any body
	CreateOrUpdateEntryByPathWithBodyWithResponse(ctx context.Context, bucketid string, params *CreateOrUpdateEntryByPathParams, contentType string, body io.Reader) (*CreateOrUpdateEntryByPathResponse, error)

	CreateOrUpdateEntryByPathWithResponse(ctx context.Context, bucketid string, params *CreateOrUpdateEntryByPathParams, body CreateOrUpdateEntryByPathJSONRequestBody) (*CreateOrUpdateEntryByPathResponse, error)

	// UpdateEntryByPath request  with any body
	UpdateEntryByPathWithBodyWithResponse(ctx context.Context, bucketid string, params *UpdateEntryByPathParams, contentType string, body io.Reader) (*UpdateEntryByPathResponse, error)

	UpdateEntryByPathWithResponse(ctx context.Context, bucketid string, params *UpdateEntryByPathParams, body UpdateEntryByPathJSONRequestBody) (*UpdateEntryByPathResponse, error)

	// DeletePermissionByBucket request
	DeletePermissionByBucketWithResponse(ctx context.Context, bucketid string, params *DeletePermissionByBucketParams) (*DeletePermissionByBucketResponse, error)

	// GetAllByBucket request
	GetAllByBucketWithResponse(ctx context.Context, bucketid string) (*GetAllByBucketResponse, error)

	// CreatePermissionByBucket request  with any body
	CreatePermissionByBucketWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*CreatePermissionByBucketResponse, error)

	CreatePermissionByBucketWithResponse(ctx context.Context, bucketid string, body CreatePermissionByBucketJSONRequestBody) (*CreatePermissionByBucketResponse, error)

	// UpdatePermissionByBucket request  with any body
	UpdatePermissionByBucketWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*UpdatePermissionByBucketResponse, error)

	UpdatePermissionByBucketWithResponse(ctx context.Context, bucketid string, body UpdatePermissionByBucketJSONRequestBody) (*UpdatePermissionByBucketResponse, error)

	// PromoteBucket request  with any body
	PromoteBucketWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*PromoteBucketResponse, error)

	PromoteBucketWithResponse(ctx context.Context, bucketid string, body PromoteBucketJSONRequestBody) (*PromoteBucketResponse, error)

	// GetPromotion request
	GetPromotionWithResponse(ctx context.Context, bucketid string, promotionid string) (*GetPromotionResponse, error)

	// PromoteBucketAsync request  with any body
	PromoteBucketAsyncWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*PromoteBucketAsyncResponse, error)

	PromoteBucketAsyncWithResponse(ctx context.Context, bucketid string, body PromoteBucketAsyncJSONRequestBody) (*PromoteBucketAsyncResponse, error)

	// GetReleaseByBadge request
	GetReleaseByBadgeWithResponse(ctx context.Context, bucketid string, badgename string) (*GetReleaseByBadgeResponse, error)

	// GetReleaseEntriesByBadge request
	GetReleaseEntriesByBadgeWithResponse(ctx context.Context, bucketid string, badgename string, params *GetReleaseEntriesByBadgeParams) (*GetReleaseEntriesByBadgeResponse, error)

	// GetReleases request
	GetReleasesWithResponse(ctx context.Context, bucketid string, params *GetReleasesParams) (*GetReleasesResponse, error)

	// CreateRelease request  with any body
	CreateReleaseWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*CreateReleaseResponse, error)

	CreateReleaseWithResponse(ctx context.Context, bucketid string, body CreateReleaseJSONRequestBody) (*CreateReleaseResponse, error)

	// GetRelease request
	GetReleaseWithResponse(ctx context.Context, bucketid string, releaseid string) (*GetReleaseResponse, error)

	// UpdateRelease request  with any body
	UpdateReleaseWithBodyWithResponse(ctx context.Context, bucketid string, releaseid string, contentType string, body io.Reader) (*UpdateReleaseResponse, error)

	UpdateReleaseWithResponse(ctx context.Context, bucketid string, releaseid string, body UpdateReleaseJSONRequestBody) (*UpdateReleaseResponse, error)

	// GetReleaseEntries request
	GetReleaseEntriesWithResponse(ctx context.Context, bucketid string, releaseid string, params *GetReleaseEntriesParams) (*GetReleaseEntriesResponse, error)

	// GetStats request
	GetStatsWithResponse(ctx context.Context, bucketid string, releaseid string, params *GetStatsParams) (*GetStatsResponse, error)

	// GetErrorDetails request
	GetErrorDetailsWithResponse(ctx context.Context, bucketid string, releaseid string, params *GetErrorDetailsParams) (*GetErrorDetailsResponse, error)

	// GetOrg request
	GetOrgWithResponse(ctx context.Context, orgid string) (*GetOrgResponse, error)

	// SaveTosAccepted request  with any body
	SaveTosAcceptedWithBodyWithResponse(ctx context.Context, orgid string, contentType string, body io.Reader) (*SaveTosAcceptedResponse, error)

	SaveTosAcceptedWithResponse(ctx context.Context, orgid string, body SaveTosAcceptedJSONRequestBody) (*SaveTosAcceptedResponse, error)

	// GetOrgUsage request
	GetOrgUsageWithResponse(ctx context.Context, orgid string) (*GetOrgUsageResponse, error)

	// ListBucketsByProject request
	ListBucketsByProjectWithResponse(ctx context.Context, projectguid string, params *ListBucketsByProjectParams) (*ListBucketsByProjectResponse, error)

	// CreateBucketByProject request  with any body
	CreateBucketByProjectWithBodyWithResponse(ctx context.Context, projectguid string, contentType string, body io.Reader) (*CreateBucketByProjectResponse, error)

	CreateBucketByProjectWithResponse(ctx context.Context, projectguid string, body CreateBucketByProjectJSONRequestBody) (*CreateBucketByProjectResponse, error)

	// GetUserInfo request
	GetUserInfoWithResponse(ctx context.Context) (*GetUserInfoResponse, error)

	// GetUserApiKey request
	GetUserApiKeyWithResponse(ctx context.Context) (*GetUserApiKeyResponse, error)

	// RegenerateUserApiKey request  with any body
	RegenerateUserApiKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*RegenerateUserApiKeyResponse, error)

	RegenerateUserApiKeyWithResponse(ctx context.Context, body RegenerateUserApiKeyJSONRequestBody) (*RegenerateUserApiKeyResponse, error)
}

type DeleteBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *Nocontent
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r DeleteBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bucket
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bucket
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r UpdateBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBucketAccessTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Bucketaccesstoken
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r ListBucketAccessTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBucketAccessTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBucketAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bucketaccesstoken
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r CreateBucketAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBucketAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBucketAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *Nocontent
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r DeleteBucketAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBucketAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBucketAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bucketaccesstoken
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetBucketAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBucketAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBucketAccessTokenInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bucketaccesstoken
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r UpdateBucketAccessTokenInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBucketAccessTokenInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBadgesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Badge
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r ListBadgesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBadgesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBadgeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Badge
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r UpdateBadgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBadgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBadgeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *Nocontent
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r DeleteBadgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBadgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBadgeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Badge
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetBadgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBadgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReleaseDiffResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Changecount
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetReleaseDiffResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReleaseDiffResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReleaseDiffEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Releaseentry
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetReleaseDiffEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReleaseDiffEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDiffResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Changecount
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetDiffResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDiffResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDiffEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Releaseentry
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetDiffEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDiffEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Entry
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Entry
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r CreateEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *[]Nocontent
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r DeleteEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Entry
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Entry
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r UpdateEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContentStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetContentStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContentStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r UploadContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r CreateContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntryVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Version
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetEntryVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntryVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntryVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Entry
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetEntryVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntryVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContentVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetContentVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContentVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContentStatusVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetContentStatusVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContentStatusVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntryByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Entry
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetEntryByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntryByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateEntryByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Entry
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateEntryByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateEntryByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEntryByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Entry
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r UpdateEntryByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEntryByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePermissionByBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Httperror
	JSON404      *Httperror
	JSON409      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r DeletePermissionByBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePermissionByBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllByBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Permission
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetAllByBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllByBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePermissionByBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Permission
	JSON400      *Httperror
	JSON404      *Httperror
	JSON409      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r CreatePermissionByBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePermissionByBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePermissionByBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Permission
	JSON400      *Httperror
	JSON404      *Httperror
	JSON409      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r UpdatePermissionByBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePermissionByBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PromoteBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Release
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r PromoteBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PromoteBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPromotionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Promotion
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetPromotionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPromotionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PromoteBucketAsyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PromoteBucketAPIResponse
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r PromoteBucketAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PromoteBucketAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReleaseByBadgeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Release
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetReleaseByBadgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReleaseByBadgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReleaseEntriesByBadgeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Releaseentry
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetReleaseEntriesByBadgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReleaseEntriesByBadgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReleasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Release
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetReleasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReleasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateReleaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Release
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r CreateReleaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateReleaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReleaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Release
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetReleaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReleaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateReleaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Release
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r UpdateReleaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateReleaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReleaseEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Releaseentry
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetReleaseEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReleaseEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricQuantity
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetErrorDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetErrorDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetErrorDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Org
	JSON400      *Httperror
	JSON403      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveTosAcceptedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Org
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r SaveTosAcceptedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveTosAcceptedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrgUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Orgusage
	JSON400      *Httperror
	JSON403      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetOrgUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrgUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBucketsByProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Bucket
	JSON400      *Httperror
	JSON404      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r ListBucketsByProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBucketsByProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBucketByProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bucket
	JSON400      *Httperror
	JSON404      *Httperror
	JSON409      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r CreateBucketByProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBucketByProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetUserInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Userapikey
	JSON400      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r GetUserApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegenerateUserApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Userapikey
	JSON400      *Httperror
	JSON500      *Httperror
	JSONDefault  *Httperror
}

// Status returns HTTPResponse.Status
func (r RegenerateUserApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegenerateUserApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteBucketWithResponse request returning *DeleteBucketResponse
func (c *ClientWithResponses) DeleteBucketWithResponse(ctx context.Context, bucketid string) (*DeleteBucketResponse, error) {
	rsp, err := c.DeleteBucket(ctx, bucketid)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBucketResponse(rsp)
}

// GetBucketWithResponse request returning *GetBucketResponse
func (c *ClientWithResponses) GetBucketWithResponse(ctx context.Context, bucketid string) (*GetBucketResponse, error) {
	rsp, err := c.GetBucket(ctx, bucketid)
	if err != nil {
		return nil, err
	}
	return ParseGetBucketResponse(rsp)
}

// UpdateBucketWithBodyWithResponse request with arbitrary body returning *UpdateBucketResponse
func (c *ClientWithResponses) UpdateBucketWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*UpdateBucketResponse, error) {
	rsp, err := c.UpdateBucketWithBody(ctx, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBucketResponse(rsp)
}

func (c *ClientWithResponses) UpdateBucketWithResponse(ctx context.Context, bucketid string, body UpdateBucketJSONRequestBody) (*UpdateBucketResponse, error) {
	rsp, err := c.UpdateBucket(ctx, bucketid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBucketResponse(rsp)
}

// ListBucketAccessTokensWithResponse request returning *ListBucketAccessTokensResponse
func (c *ClientWithResponses) ListBucketAccessTokensWithResponse(ctx context.Context, bucketid string, params *ListBucketAccessTokensParams) (*ListBucketAccessTokensResponse, error) {
	rsp, err := c.ListBucketAccessTokens(ctx, bucketid, params)
	if err != nil {
		return nil, err
	}
	return ParseListBucketAccessTokensResponse(rsp)
}

// CreateBucketAccessTokenWithBodyWithResponse request with arbitrary body returning *CreateBucketAccessTokenResponse
func (c *ClientWithResponses) CreateBucketAccessTokenWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*CreateBucketAccessTokenResponse, error) {
	rsp, err := c.CreateBucketAccessTokenWithBody(ctx, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateBucketAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateBucketAccessTokenWithResponse(ctx context.Context, bucketid string, body CreateBucketAccessTokenJSONRequestBody) (*CreateBucketAccessTokenResponse, error) {
	rsp, err := c.CreateBucketAccessToken(ctx, bucketid, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateBucketAccessTokenResponse(rsp)
}

// DeleteBucketAccessTokenWithResponse request returning *DeleteBucketAccessTokenResponse
func (c *ClientWithResponses) DeleteBucketAccessTokenWithResponse(ctx context.Context, bucketid string, tokenid string) (*DeleteBucketAccessTokenResponse, error) {
	rsp, err := c.DeleteBucketAccessToken(ctx, bucketid, tokenid)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBucketAccessTokenResponse(rsp)
}

// GetBucketAccessTokenWithResponse request returning *GetBucketAccessTokenResponse
func (c *ClientWithResponses) GetBucketAccessTokenWithResponse(ctx context.Context, bucketid string, tokenid string) (*GetBucketAccessTokenResponse, error) {
	rsp, err := c.GetBucketAccessToken(ctx, bucketid, tokenid)
	if err != nil {
		return nil, err
	}
	return ParseGetBucketAccessTokenResponse(rsp)
}

// UpdateBucketAccessTokenInfoWithBodyWithResponse request with arbitrary body returning *UpdateBucketAccessTokenInfoResponse
func (c *ClientWithResponses) UpdateBucketAccessTokenInfoWithBodyWithResponse(ctx context.Context, bucketid string, tokenid string, contentType string, body io.Reader) (*UpdateBucketAccessTokenInfoResponse, error) {
	rsp, err := c.UpdateBucketAccessTokenInfoWithBody(ctx, bucketid, tokenid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBucketAccessTokenInfoResponse(rsp)
}

func (c *ClientWithResponses) UpdateBucketAccessTokenInfoWithResponse(ctx context.Context, bucketid string, tokenid string, body UpdateBucketAccessTokenInfoJSONRequestBody) (*UpdateBucketAccessTokenInfoResponse, error) {
	rsp, err := c.UpdateBucketAccessTokenInfo(ctx, bucketid, tokenid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBucketAccessTokenInfoResponse(rsp)
}

// ListBadgesWithResponse request returning *ListBadgesResponse
func (c *ClientWithResponses) ListBadgesWithResponse(ctx context.Context, bucketid string, params *ListBadgesParams) (*ListBadgesResponse, error) {
	rsp, err := c.ListBadges(ctx, bucketid, params)
	if err != nil {
		return nil, err
	}
	return ParseListBadgesResponse(rsp)
}

// UpdateBadgeWithBodyWithResponse request with arbitrary body returning *UpdateBadgeResponse
func (c *ClientWithResponses) UpdateBadgeWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*UpdateBadgeResponse, error) {
	rsp, err := c.UpdateBadgeWithBody(ctx, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBadgeResponse(rsp)
}

func (c *ClientWithResponses) UpdateBadgeWithResponse(ctx context.Context, bucketid string, body UpdateBadgeJSONRequestBody) (*UpdateBadgeResponse, error) {
	rsp, err := c.UpdateBadge(ctx, bucketid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBadgeResponse(rsp)
}

// DeleteBadgeWithResponse request returning *DeleteBadgeResponse
func (c *ClientWithResponses) DeleteBadgeWithResponse(ctx context.Context, bucketid string, badgename string) (*DeleteBadgeResponse, error) {
	rsp, err := c.DeleteBadge(ctx, bucketid, badgename)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBadgeResponse(rsp)
}

// GetBadgeWithResponse request returning *GetBadgeResponse
func (c *ClientWithResponses) GetBadgeWithResponse(ctx context.Context, bucketid string, badgename string) (*GetBadgeResponse, error) {
	rsp, err := c.GetBadge(ctx, bucketid, badgename)
	if err != nil {
		return nil, err
	}
	return ParseGetBadgeResponse(rsp)
}

// GetReleaseDiffWithResponse request returning *GetReleaseDiffResponse
func (c *ClientWithResponses) GetReleaseDiffWithResponse(ctx context.Context, bucketid string, params *GetReleaseDiffParams) (*GetReleaseDiffResponse, error) {
	rsp, err := c.GetReleaseDiff(ctx, bucketid, params)
	if err != nil {
		return nil, err
	}
	return ParseGetReleaseDiffResponse(rsp)
}

// GetReleaseDiffEntriesWithResponse request returning *GetReleaseDiffEntriesResponse
func (c *ClientWithResponses) GetReleaseDiffEntriesWithResponse(ctx context.Context, bucketid string, params *GetReleaseDiffEntriesParams) (*GetReleaseDiffEntriesResponse, error) {
	rsp, err := c.GetReleaseDiffEntries(ctx, bucketid, params)
	if err != nil {
		return nil, err
	}
	return ParseGetReleaseDiffEntriesResponse(rsp)
}

// GetDiffWithResponse request returning *GetDiffResponse
func (c *ClientWithResponses) GetDiffWithResponse(ctx context.Context, bucketid string) (*GetDiffResponse, error) {
	rsp, err := c.GetDiff(ctx, bucketid)
	if err != nil {
		return nil, err
	}
	return ParseGetDiffResponse(rsp)
}

// GetDiffEntriesWithResponse request returning *GetDiffEntriesResponse
func (c *ClientWithResponses) GetDiffEntriesWithResponse(ctx context.Context, bucketid string, params *GetDiffEntriesParams) (*GetDiffEntriesResponse, error) {
	rsp, err := c.GetDiffEntries(ctx, bucketid, params)
	if err != nil {
		return nil, err
	}
	return ParseGetDiffEntriesResponse(rsp)
}

// GetEntriesWithResponse request returning *GetEntriesResponse
func (c *ClientWithResponses) GetEntriesWithResponse(ctx context.Context, bucketid string, params *GetEntriesParams) (*GetEntriesResponse, error) {
	rsp, err := c.GetEntries(ctx, bucketid, params)
	if err != nil {
		return nil, err
	}
	return ParseGetEntriesResponse(rsp)
}

// CreateEntryWithBodyWithResponse request with arbitrary body returning *CreateEntryResponse
func (c *ClientWithResponses) CreateEntryWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*CreateEntryResponse, error) {
	rsp, err := c.CreateEntryWithBody(ctx, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateEntryResponse(rsp)
}

func (c *ClientWithResponses) CreateEntryWithResponse(ctx context.Context, bucketid string, body CreateEntryJSONRequestBody) (*CreateEntryResponse, error) {
	rsp, err := c.CreateEntry(ctx, bucketid, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateEntryResponse(rsp)
}

// DeleteEntryWithResponse request returning *DeleteEntryResponse
func (c *ClientWithResponses) DeleteEntryWithResponse(ctx context.Context, bucketid string, entryid string) (*DeleteEntryResponse, error) {
	rsp, err := c.DeleteEntry(ctx, bucketid, entryid)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEntryResponse(rsp)
}

// GetEntryWithResponse request returning *GetEntryResponse
func (c *ClientWithResponses) GetEntryWithResponse(ctx context.Context, bucketid string, entryid string) (*GetEntryResponse, error) {
	rsp, err := c.GetEntry(ctx, bucketid, entryid)
	if err != nil {
		return nil, err
	}
	return ParseGetEntryResponse(rsp)
}

// UpdateEntryWithBodyWithResponse request with arbitrary body returning *UpdateEntryResponse
func (c *ClientWithResponses) UpdateEntryWithBodyWithResponse(ctx context.Context, bucketid string, entryid string, contentType string, body io.Reader) (*UpdateEntryResponse, error) {
	rsp, err := c.UpdateEntryWithBody(ctx, bucketid, entryid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEntryResponse(rsp)
}

func (c *ClientWithResponses) UpdateEntryWithResponse(ctx context.Context, bucketid string, entryid string, body UpdateEntryJSONRequestBody) (*UpdateEntryResponse, error) {
	rsp, err := c.UpdateEntry(ctx, bucketid, entryid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEntryResponse(rsp)
}

// GetContentWithResponse request returning *GetContentResponse
func (c *ClientWithResponses) GetContentWithResponse(ctx context.Context, bucketid string, entryid string, params *GetContentParams) (*GetContentResponse, error) {
	rsp, err := c.GetContent(ctx, bucketid, entryid, params)
	if err != nil {
		return nil, err
	}
	return ParseGetContentResponse(rsp)
}

// GetContentStatusWithResponse request returning *GetContentStatusResponse
func (c *ClientWithResponses) GetContentStatusWithResponse(ctx context.Context, bucketid string, entryid string, params *GetContentStatusParams) (*GetContentStatusResponse, error) {
	rsp, err := c.GetContentStatus(ctx, bucketid, entryid, params)
	if err != nil {
		return nil, err
	}
	return ParseGetContentStatusResponse(rsp)
}

// UploadContentWithBodyWithResponse request with arbitrary body returning *UploadContentResponse
func (c *ClientWithResponses) UploadContentWithBodyWithResponse(ctx context.Context, bucketid string, entryid string, params *UploadContentParams, contentType string, body io.Reader) (*UploadContentResponse, error) {
	rsp, err := c.UploadContentWithBody(ctx, bucketid, entryid, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUploadContentResponse(rsp)
}

// CreateContentWithResponse request returning *CreateContentResponse
func (c *ClientWithResponses) CreateContentWithResponse(ctx context.Context, bucketid string, entryid string, params *CreateContentParams) (*CreateContentResponse, error) {
	rsp, err := c.CreateContent(ctx, bucketid, entryid, params)
	if err != nil {
		return nil, err
	}
	return ParseCreateContentResponse(rsp)
}

// GetEntryVersionsWithResponse request returning *GetEntryVersionsResponse
func (c *ClientWithResponses) GetEntryVersionsWithResponse(ctx context.Context, bucketid string, entryid string, params *GetEntryVersionsParams) (*GetEntryVersionsResponse, error) {
	rsp, err := c.GetEntryVersions(ctx, bucketid, entryid, params)
	if err != nil {
		return nil, err
	}
	return ParseGetEntryVersionsResponse(rsp)
}

// GetEntryVersionWithResponse request returning *GetEntryVersionResponse
func (c *ClientWithResponses) GetEntryVersionWithResponse(ctx context.Context, bucketid string, entryid string, versionid string) (*GetEntryVersionResponse, error) {
	rsp, err := c.GetEntryVersion(ctx, bucketid, entryid, versionid)
	if err != nil {
		return nil, err
	}
	return ParseGetEntryVersionResponse(rsp)
}

// GetContentVersionWithResponse request returning *GetContentVersionResponse
func (c *ClientWithResponses) GetContentVersionWithResponse(ctx context.Context, bucketid string, entryid string, versionid string) (*GetContentVersionResponse, error) {
	rsp, err := c.GetContentVersion(ctx, bucketid, entryid, versionid)
	if err != nil {
		return nil, err
	}
	return ParseGetContentVersionResponse(rsp)
}

// GetContentStatusVersionWithResponse request returning *GetContentStatusVersionResponse
func (c *ClientWithResponses) GetContentStatusVersionWithResponse(ctx context.Context, bucketid string, entryid string, versionid string) (*GetContentStatusVersionResponse, error) {
	rsp, err := c.GetContentStatusVersion(ctx, bucketid, entryid, versionid)
	if err != nil {
		return nil, err
	}
	return ParseGetContentStatusVersionResponse(rsp)
}

// GetEntryByPathWithResponse request returning *GetEntryByPathResponse
func (c *ClientWithResponses) GetEntryByPathWithResponse(ctx context.Context, bucketid string, params *GetEntryByPathParams) (*GetEntryByPathResponse, error) {
	rsp, err := c.GetEntryByPath(ctx, bucketid, params)
	if err != nil {
		return nil, err
	}
	return ParseGetEntryByPathResponse(rsp)
}

// CreateOrUpdateEntryByPathWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateEntryByPathResponse
func (c *ClientWithResponses) CreateOrUpdateEntryByPathWithBodyWithResponse(ctx context.Context, bucketid string, params *CreateOrUpdateEntryByPathParams, contentType string, body io.Reader) (*CreateOrUpdateEntryByPathResponse, error) {
	rsp, err := c.CreateOrUpdateEntryByPathWithBody(ctx, bucketid, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateEntryByPathResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateEntryByPathWithResponse(ctx context.Context, bucketid string, params *CreateOrUpdateEntryByPathParams, body CreateOrUpdateEntryByPathJSONRequestBody) (*CreateOrUpdateEntryByPathResponse, error) {
	rsp, err := c.CreateOrUpdateEntryByPath(ctx, bucketid, params, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateEntryByPathResponse(rsp)
}

// UpdateEntryByPathWithBodyWithResponse request with arbitrary body returning *UpdateEntryByPathResponse
func (c *ClientWithResponses) UpdateEntryByPathWithBodyWithResponse(ctx context.Context, bucketid string, params *UpdateEntryByPathParams, contentType string, body io.Reader) (*UpdateEntryByPathResponse, error) {
	rsp, err := c.UpdateEntryByPathWithBody(ctx, bucketid, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEntryByPathResponse(rsp)
}

func (c *ClientWithResponses) UpdateEntryByPathWithResponse(ctx context.Context, bucketid string, params *UpdateEntryByPathParams, body UpdateEntryByPathJSONRequestBody) (*UpdateEntryByPathResponse, error) {
	rsp, err := c.UpdateEntryByPath(ctx, bucketid, params, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEntryByPathResponse(rsp)
}

// DeletePermissionByBucketWithResponse request returning *DeletePermissionByBucketResponse
func (c *ClientWithResponses) DeletePermissionByBucketWithResponse(ctx context.Context, bucketid string, params *DeletePermissionByBucketParams) (*DeletePermissionByBucketResponse, error) {
	rsp, err := c.DeletePermissionByBucket(ctx, bucketid, params)
	if err != nil {
		return nil, err
	}
	return ParseDeletePermissionByBucketResponse(rsp)
}

// GetAllByBucketWithResponse request returning *GetAllByBucketResponse
func (c *ClientWithResponses) GetAllByBucketWithResponse(ctx context.Context, bucketid string) (*GetAllByBucketResponse, error) {
	rsp, err := c.GetAllByBucket(ctx, bucketid)
	if err != nil {
		return nil, err
	}
	return ParseGetAllByBucketResponse(rsp)
}

// CreatePermissionByBucketWithBodyWithResponse request with arbitrary body returning *CreatePermissionByBucketResponse
func (c *ClientWithResponses) CreatePermissionByBucketWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*CreatePermissionByBucketResponse, error) {
	rsp, err := c.CreatePermissionByBucketWithBody(ctx, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreatePermissionByBucketResponse(rsp)
}

func (c *ClientWithResponses) CreatePermissionByBucketWithResponse(ctx context.Context, bucketid string, body CreatePermissionByBucketJSONRequestBody) (*CreatePermissionByBucketResponse, error) {
	rsp, err := c.CreatePermissionByBucket(ctx, bucketid, body)
	if err != nil {
		return nil, err
	}
	return ParseCreatePermissionByBucketResponse(rsp)
}

// UpdatePermissionByBucketWithBodyWithResponse request with arbitrary body returning *UpdatePermissionByBucketResponse
func (c *ClientWithResponses) UpdatePermissionByBucketWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*UpdatePermissionByBucketResponse, error) {
	rsp, err := c.UpdatePermissionByBucketWithBody(ctx, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePermissionByBucketResponse(rsp)
}

func (c *ClientWithResponses) UpdatePermissionByBucketWithResponse(ctx context.Context, bucketid string, body UpdatePermissionByBucketJSONRequestBody) (*UpdatePermissionByBucketResponse, error) {
	rsp, err := c.UpdatePermissionByBucket(ctx, bucketid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePermissionByBucketResponse(rsp)
}

// PromoteBucketWithBodyWithResponse request with arbitrary body returning *PromoteBucketResponse
func (c *ClientWithResponses) PromoteBucketWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*PromoteBucketResponse, error) {
	rsp, err := c.PromoteBucketWithBody(ctx, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePromoteBucketResponse(rsp)
}

func (c *ClientWithResponses) PromoteBucketWithResponse(ctx context.Context, bucketid string, body PromoteBucketJSONRequestBody) (*PromoteBucketResponse, error) {
	rsp, err := c.PromoteBucket(ctx, bucketid, body)
	if err != nil {
		return nil, err
	}
	return ParsePromoteBucketResponse(rsp)
}

// GetPromotionWithResponse request returning *GetPromotionResponse
func (c *ClientWithResponses) GetPromotionWithResponse(ctx context.Context, bucketid string, promotionid string) (*GetPromotionResponse, error) {
	rsp, err := c.GetPromotion(ctx, bucketid, promotionid)
	if err != nil {
		return nil, err
	}
	return ParseGetPromotionResponse(rsp)
}

// PromoteBucketAsyncWithBodyWithResponse request with arbitrary body returning *PromoteBucketAsyncResponse
func (c *ClientWithResponses) PromoteBucketAsyncWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*PromoteBucketAsyncResponse, error) {
	rsp, err := c.PromoteBucketAsyncWithBody(ctx, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePromoteBucketAsyncResponse(rsp)
}

func (c *ClientWithResponses) PromoteBucketAsyncWithResponse(ctx context.Context, bucketid string, body PromoteBucketAsyncJSONRequestBody) (*PromoteBucketAsyncResponse, error) {
	rsp, err := c.PromoteBucketAsync(ctx, bucketid, body)
	if err != nil {
		return nil, err
	}
	return ParsePromoteBucketAsyncResponse(rsp)
}

// GetReleaseByBadgeWithResponse request returning *GetReleaseByBadgeResponse
func (c *ClientWithResponses) GetReleaseByBadgeWithResponse(ctx context.Context, bucketid string, badgename string) (*GetReleaseByBadgeResponse, error) {
	rsp, err := c.GetReleaseByBadge(ctx, bucketid, badgename)
	if err != nil {
		return nil, err
	}
	return ParseGetReleaseByBadgeResponse(rsp)
}

// GetReleaseEntriesByBadgeWithResponse request returning *GetReleaseEntriesByBadgeResponse
func (c *ClientWithResponses) GetReleaseEntriesByBadgeWithResponse(ctx context.Context, bucketid string, badgename string, params *GetReleaseEntriesByBadgeParams) (*GetReleaseEntriesByBadgeResponse, error) {
	rsp, err := c.GetReleaseEntriesByBadge(ctx, bucketid, badgename, params)
	if err != nil {
		return nil, err
	}
	return ParseGetReleaseEntriesByBadgeResponse(rsp)
}

// GetReleasesWithResponse request returning *GetReleasesResponse
func (c *ClientWithResponses) GetReleasesWithResponse(ctx context.Context, bucketid string, params *GetReleasesParams) (*GetReleasesResponse, error) {
	rsp, err := c.GetReleases(ctx, bucketid, params)
	if err != nil {
		return nil, err
	}
	return ParseGetReleasesResponse(rsp)
}

// CreateReleaseWithBodyWithResponse request with arbitrary body returning *CreateReleaseResponse
func (c *ClientWithResponses) CreateReleaseWithBodyWithResponse(ctx context.Context, bucketid string, contentType string, body io.Reader) (*CreateReleaseResponse, error) {
	rsp, err := c.CreateReleaseWithBody(ctx, bucketid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateReleaseResponse(rsp)
}

func (c *ClientWithResponses) CreateReleaseWithResponse(ctx context.Context, bucketid string, body CreateReleaseJSONRequestBody) (*CreateReleaseResponse, error) {
	rsp, err := c.CreateRelease(ctx, bucketid, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateReleaseResponse(rsp)
}

// GetReleaseWithResponse request returning *GetReleaseResponse
func (c *ClientWithResponses) GetReleaseWithResponse(ctx context.Context, bucketid string, releaseid string) (*GetReleaseResponse, error) {
	rsp, err := c.GetRelease(ctx, bucketid, releaseid)
	if err != nil {
		return nil, err
	}
	return ParseGetReleaseResponse(rsp)
}

// UpdateReleaseWithBodyWithResponse request with arbitrary body returning *UpdateReleaseResponse
func (c *ClientWithResponses) UpdateReleaseWithBodyWithResponse(ctx context.Context, bucketid string, releaseid string, contentType string, body io.Reader) (*UpdateReleaseResponse, error) {
	rsp, err := c.UpdateReleaseWithBody(ctx, bucketid, releaseid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateReleaseResponse(rsp)
}

func (c *ClientWithResponses) UpdateReleaseWithResponse(ctx context.Context, bucketid string, releaseid string, body UpdateReleaseJSONRequestBody) (*UpdateReleaseResponse, error) {
	rsp, err := c.UpdateRelease(ctx, bucketid, releaseid, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateReleaseResponse(rsp)
}

// GetReleaseEntriesWithResponse request returning *GetReleaseEntriesResponse
func (c *ClientWithResponses) GetReleaseEntriesWithResponse(ctx context.Context, bucketid string, releaseid string, params *GetReleaseEntriesParams) (*GetReleaseEntriesResponse, error) {
	rsp, err := c.GetReleaseEntries(ctx, bucketid, releaseid, params)
	if err != nil {
		return nil, err
	}
	return ParseGetReleaseEntriesResponse(rsp)
}

// GetStatsWithResponse request returning *GetStatsResponse
func (c *ClientWithResponses) GetStatsWithResponse(ctx context.Context, bucketid string, releaseid string, params *GetStatsParams) (*GetStatsResponse, error) {
	rsp, err := c.GetStats(ctx, bucketid, releaseid, params)
	if err != nil {
		return nil, err
	}
	return ParseGetStatsResponse(rsp)
}

// GetErrorDetailsWithResponse request returning *GetErrorDetailsResponse
func (c *ClientWithResponses) GetErrorDetailsWithResponse(ctx context.Context, bucketid string, releaseid string, params *GetErrorDetailsParams) (*GetErrorDetailsResponse, error) {
	rsp, err := c.GetErrorDetails(ctx, bucketid, releaseid, params)
	if err != nil {
		return nil, err
	}
	return ParseGetErrorDetailsResponse(rsp)
}

// GetOrgWithResponse request returning *GetOrgResponse
func (c *ClientWithResponses) GetOrgWithResponse(ctx context.Context, orgid string) (*GetOrgResponse, error) {
	rsp, err := c.GetOrg(ctx, orgid)
	if err != nil {
		return nil, err
	}
	return ParseGetOrgResponse(rsp)
}

// SaveTosAcceptedWithBodyWithResponse request with arbitrary body returning *SaveTosAcceptedResponse
func (c *ClientWithResponses) SaveTosAcceptedWithBodyWithResponse(ctx context.Context, orgid string, contentType string, body io.Reader) (*SaveTosAcceptedResponse, error) {
	rsp, err := c.SaveTosAcceptedWithBody(ctx, orgid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSaveTosAcceptedResponse(rsp)
}

func (c *ClientWithResponses) SaveTosAcceptedWithResponse(ctx context.Context, orgid string, body SaveTosAcceptedJSONRequestBody) (*SaveTosAcceptedResponse, error) {
	rsp, err := c.SaveTosAccepted(ctx, orgid, body)
	if err != nil {
		return nil, err
	}
	return ParseSaveTosAcceptedResponse(rsp)
}

// GetOrgUsageWithResponse request returning *GetOrgUsageResponse
func (c *ClientWithResponses) GetOrgUsageWithResponse(ctx context.Context, orgid string) (*GetOrgUsageResponse, error) {
	rsp, err := c.GetOrgUsage(ctx, orgid)
	if err != nil {
		return nil, err
	}
	return ParseGetOrgUsageResponse(rsp)
}

// ListBucketsByProjectWithResponse request returning *ListBucketsByProjectResponse
func (c *ClientWithResponses) ListBucketsByProjectWithResponse(ctx context.Context, projectguid string, params *ListBucketsByProjectParams) (*ListBucketsByProjectResponse, error) {
	rsp, err := c.ListBucketsByProject(ctx, projectguid, params)
	if err != nil {
		return nil, err
	}
	return ParseListBucketsByProjectResponse(rsp)
}

// CreateBucketByProjectWithBodyWithResponse request with arbitrary body returning *CreateBucketByProjectResponse
func (c *ClientWithResponses) CreateBucketByProjectWithBodyWithResponse(ctx context.Context, projectguid string, contentType string, body io.Reader) (*CreateBucketByProjectResponse, error) {
	rsp, err := c.CreateBucketByProjectWithBody(ctx, projectguid, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateBucketByProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateBucketByProjectWithResponse(ctx context.Context, projectguid string, body CreateBucketByProjectJSONRequestBody) (*CreateBucketByProjectResponse, error) {
	rsp, err := c.CreateBucketByProject(ctx, projectguid, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateBucketByProjectResponse(rsp)
}

// GetUserInfoWithResponse request returning *GetUserInfoResponse
func (c *ClientWithResponses) GetUserInfoWithResponse(ctx context.Context) (*GetUserInfoResponse, error) {
	rsp, err := c.GetUserInfo(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetUserInfoResponse(rsp)
}

// GetUserApiKeyWithResponse request returning *GetUserApiKeyResponse
func (c *ClientWithResponses) GetUserApiKeyWithResponse(ctx context.Context) (*GetUserApiKeyResponse, error) {
	rsp, err := c.GetUserApiKey(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetUserApiKeyResponse(rsp)
}

// RegenerateUserApiKeyWithBodyWithResponse request with arbitrary body returning *RegenerateUserApiKeyResponse
func (c *ClientWithResponses) RegenerateUserApiKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*RegenerateUserApiKeyResponse, error) {
	rsp, err := c.RegenerateUserApiKeyWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseRegenerateUserApiKeyResponse(rsp)
}

func (c *ClientWithResponses) RegenerateUserApiKeyWithResponse(ctx context.Context, body RegenerateUserApiKeyJSONRequestBody) (*RegenerateUserApiKeyResponse, error) {
	rsp, err := c.RegenerateUserApiKey(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseRegenerateUserApiKeyResponse(rsp)
}

// ParseDeleteBucketResponse parses an HTTP response from a DeleteBucketWithResponse call
func ParseDeleteBucketResponse(rsp *http.Response) (*DeleteBucketResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest Nocontent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBucketResponse parses an HTTP response from a GetBucketWithResponse call
func ParseGetBucketResponse(rsp *http.Response) (*GetBucketResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bucket
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateBucketResponse parses an HTTP response from a UpdateBucketWithResponse call
func ParseUpdateBucketResponse(rsp *http.Response) (*UpdateBucketResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bucket
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListBucketAccessTokensResponse parses an HTTP response from a ListBucketAccessTokensWithResponse call
func ParseListBucketAccessTokensResponse(rsp *http.Response) (*ListBucketAccessTokensResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListBucketAccessTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Bucketaccesstoken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBucketAccessTokenResponse parses an HTTP response from a CreateBucketAccessTokenWithResponse call
func ParseCreateBucketAccessTokenResponse(rsp *http.Response) (*CreateBucketAccessTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateBucketAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bucketaccesstoken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBucketAccessTokenResponse parses an HTTP response from a DeleteBucketAccessTokenWithResponse call
func ParseDeleteBucketAccessTokenResponse(rsp *http.Response) (*DeleteBucketAccessTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteBucketAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest Nocontent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBucketAccessTokenResponse parses an HTTP response from a GetBucketAccessTokenWithResponse call
func ParseGetBucketAccessTokenResponse(rsp *http.Response) (*GetBucketAccessTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetBucketAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bucketaccesstoken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateBucketAccessTokenInfoResponse parses an HTTP response from a UpdateBucketAccessTokenInfoWithResponse call
func ParseUpdateBucketAccessTokenInfoResponse(rsp *http.Response) (*UpdateBucketAccessTokenInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateBucketAccessTokenInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bucketaccesstoken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListBadgesResponse parses an HTTP response from a ListBadgesWithResponse call
func ParseListBadgesResponse(rsp *http.Response) (*ListBadgesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListBadgesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Badge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateBadgeResponse parses an HTTP response from a UpdateBadgeWithResponse call
func ParseUpdateBadgeResponse(rsp *http.Response) (*UpdateBadgeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateBadgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Badge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBadgeResponse parses an HTTP response from a DeleteBadgeWithResponse call
func ParseDeleteBadgeResponse(rsp *http.Response) (*DeleteBadgeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteBadgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest Nocontent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBadgeResponse parses an HTTP response from a GetBadgeWithResponse call
func ParseGetBadgeResponse(rsp *http.Response) (*GetBadgeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetBadgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Badge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReleaseDiffResponse parses an HTTP response from a GetReleaseDiffWithResponse call
func ParseGetReleaseDiffResponse(rsp *http.Response) (*GetReleaseDiffResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetReleaseDiffResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Changecount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReleaseDiffEntriesResponse parses an HTTP response from a GetReleaseDiffEntriesWithResponse call
func ParseGetReleaseDiffEntriesResponse(rsp *http.Response) (*GetReleaseDiffEntriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetReleaseDiffEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Releaseentry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDiffResponse parses an HTTP response from a GetDiffWithResponse call
func ParseGetDiffResponse(rsp *http.Response) (*GetDiffResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetDiffResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Changecount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDiffEntriesResponse parses an HTTP response from a GetDiffEntriesWithResponse call
func ParseGetDiffEntriesResponse(rsp *http.Response) (*GetDiffEntriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetDiffEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Releaseentry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEntriesResponse parses an HTTP response from a GetEntriesWithResponse call
func ParseGetEntriesResponse(rsp *http.Response) (*GetEntriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Entry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateEntryResponse parses an HTTP response from a CreateEntryWithResponse call
func ParseCreateEntryResponse(rsp *http.Response) (*CreateEntryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Entry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteEntryResponse parses an HTTP response from a DeleteEntryWithResponse call
func ParseDeleteEntryResponse(rsp *http.Response) (*DeleteEntryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest []Nocontent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEntryResponse parses an HTTP response from a GetEntryWithResponse call
func ParseGetEntryResponse(rsp *http.Response) (*GetEntryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Entry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateEntryResponse parses an HTTP response from a UpdateEntryWithResponse call
func ParseUpdateEntryResponse(rsp *http.Response) (*UpdateEntryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Entry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetContentResponse parses an HTTP response from a GetContentWithResponse call
func ParseGetContentResponse(rsp *http.Response) (*GetContentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetContentStatusResponse parses an HTTP response from a GetContentStatusWithResponse call
func ParseGetContentStatusResponse(rsp *http.Response) (*GetContentStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetContentStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadContentResponse parses an HTTP response from a UploadContentWithResponse call
func ParseUploadContentResponse(rsp *http.Response) (*UploadContentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UploadContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateContentResponse parses an HTTP response from a CreateContentWithResponse call
func ParseCreateContentResponse(rsp *http.Response) (*CreateContentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEntryVersionsResponse parses an HTTP response from a GetEntryVersionsWithResponse call
func ParseGetEntryVersionsResponse(rsp *http.Response) (*GetEntryVersionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetEntryVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Version
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEntryVersionResponse parses an HTTP response from a GetEntryVersionWithResponse call
func ParseGetEntryVersionResponse(rsp *http.Response) (*GetEntryVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetEntryVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Entry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetContentVersionResponse parses an HTTP response from a GetContentVersionWithResponse call
func ParseGetContentVersionResponse(rsp *http.Response) (*GetContentVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetContentVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetContentStatusVersionResponse parses an HTTP response from a GetContentStatusVersionWithResponse call
func ParseGetContentStatusVersionResponse(rsp *http.Response) (*GetContentStatusVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetContentStatusVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEntryByPathResponse parses an HTTP response from a GetEntryByPathWithResponse call
func ParseGetEntryByPathResponse(rsp *http.Response) (*GetEntryByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetEntryByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Entry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateEntryByPathResponse parses an HTTP response from a CreateOrUpdateEntryByPathWithResponse call
func ParseCreateOrUpdateEntryByPathResponse(rsp *http.Response) (*CreateOrUpdateEntryByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateEntryByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Entry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateEntryByPathResponse parses an HTTP response from a UpdateEntryByPathWithResponse call
func ParseUpdateEntryByPathResponse(rsp *http.Response) (*UpdateEntryByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateEntryByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Entry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePermissionByBucketResponse parses an HTTP response from a DeletePermissionByBucketWithResponse call
func ParseDeletePermissionByBucketResponse(rsp *http.Response) (*DeletePermissionByBucketResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeletePermissionByBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllByBucketResponse parses an HTTP response from a GetAllByBucketWithResponse call
func ParseGetAllByBucketResponse(rsp *http.Response) (*GetAllByBucketResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAllByBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Permission
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePermissionByBucketResponse parses an HTTP response from a CreatePermissionByBucketWithResponse call
func ParseCreatePermissionByBucketResponse(rsp *http.Response) (*CreatePermissionByBucketResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreatePermissionByBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Permission
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdatePermissionByBucketResponse parses an HTTP response from a UpdatePermissionByBucketWithResponse call
func ParseUpdatePermissionByBucketResponse(rsp *http.Response) (*UpdatePermissionByBucketResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdatePermissionByBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Permission
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePromoteBucketResponse parses an HTTP response from a PromoteBucketWithResponse call
func ParsePromoteBucketResponse(rsp *http.Response) (*PromoteBucketResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PromoteBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Release
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPromotionResponse parses an HTTP response from a GetPromotionWithResponse call
func ParseGetPromotionResponse(rsp *http.Response) (*GetPromotionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPromotionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Promotion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePromoteBucketAsyncResponse parses an HTTP response from a PromoteBucketAsyncWithResponse call
func ParsePromoteBucketAsyncResponse(rsp *http.Response) (*PromoteBucketAsyncResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PromoteBucketAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PromoteBucketAPIResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReleaseByBadgeResponse parses an HTTP response from a GetReleaseByBadgeWithResponse call
func ParseGetReleaseByBadgeResponse(rsp *http.Response) (*GetReleaseByBadgeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetReleaseByBadgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Release
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReleaseEntriesByBadgeResponse parses an HTTP response from a GetReleaseEntriesByBadgeWithResponse call
func ParseGetReleaseEntriesByBadgeResponse(rsp *http.Response) (*GetReleaseEntriesByBadgeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetReleaseEntriesByBadgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Releaseentry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReleasesResponse parses an HTTP response from a GetReleasesWithResponse call
func ParseGetReleasesResponse(rsp *http.Response) (*GetReleasesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetReleasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Release
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateReleaseResponse parses an HTTP response from a CreateReleaseWithResponse call
func ParseCreateReleaseResponse(rsp *http.Response) (*CreateReleaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateReleaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Release
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReleaseResponse parses an HTTP response from a GetReleaseWithResponse call
func ParseGetReleaseResponse(rsp *http.Response) (*GetReleaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetReleaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Release
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateReleaseResponse parses an HTTP response from a UpdateReleaseWithResponse call
func ParseUpdateReleaseResponse(rsp *http.Response) (*UpdateReleaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateReleaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Release
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReleaseEntriesResponse parses an HTTP response from a GetReleaseEntriesWithResponse call
func ParseGetReleaseEntriesResponse(rsp *http.Response) (*GetReleaseEntriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetReleaseEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Releaseentry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStatsResponse parses an HTTP response from a GetStatsWithResponse call
func ParseGetStatsResponse(rsp *http.Response) (*GetStatsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricQuantity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetErrorDetailsResponse parses an HTTP response from a GetErrorDetailsWithResponse call
func ParseGetErrorDetailsResponse(rsp *http.Response) (*GetErrorDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetErrorDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetOrgResponse parses an HTTP response from a GetOrgWithResponse call
func ParseGetOrgResponse(rsp *http.Response) (*GetOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Org
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSaveTosAcceptedResponse parses an HTTP response from a SaveTosAcceptedWithResponse call
func ParseSaveTosAcceptedResponse(rsp *http.Response) (*SaveTosAcceptedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SaveTosAcceptedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Org
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOrgUsageResponse parses an HTTP response from a GetOrgUsageWithResponse call
func ParseGetOrgUsageResponse(rsp *http.Response) (*GetOrgUsageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetOrgUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Orgusage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListBucketsByProjectResponse parses an HTTP response from a ListBucketsByProjectWithResponse call
func ParseListBucketsByProjectResponse(rsp *http.Response) (*ListBucketsByProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListBucketsByProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Bucket
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBucketByProjectResponse parses an HTTP response from a CreateBucketByProjectWithResponse call
func ParseCreateBucketByProjectResponse(rsp *http.Response) (*CreateBucketByProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateBucketByProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bucket
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserInfoResponse parses an HTTP response from a GetUserInfoWithResponse call
func ParseGetUserInfoResponse(rsp *http.Response) (*GetUserInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUserInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserApiKeyResponse parses an HTTP response from a GetUserApiKeyWithResponse call
func ParseGetUserApiKeyResponse(rsp *http.Response) (*GetUserApiKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUserApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Userapikey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRegenerateUserApiKeyResponse parses an HTTP response from a RegenerateUserApiKeyWithResponse call
func ParseRegenerateUserApiKeyResponse(rsp *http.Response) (*RegenerateUserApiKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RegenerateUserApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Userapikey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Httperror
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
